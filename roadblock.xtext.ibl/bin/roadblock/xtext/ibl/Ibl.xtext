// xtext grammar for Roadblock IBL language
// 2013, released under GNU GPL V3
// jamie.twycross AT nottingham.ac.uk

grammar roadblock.xtext.ibl.Ibl with org.eclipse.xtext.common.Terminals

generate ibl "http://www.xtext.roadblock/ibl/Ibl"

/////////////////////
// top level rules //
/////////////////////

// a model is composed of top level model members
Model:
	{Model}
	members+=ModelMember*
;
	
// model members are an import statement, variable definition or function definition
ModelMember:
	ImportStatement | FunctionDefinition
;

//////////////////////
// import statement //
//////////////////////

ImportStatement:
	{Import}
	'import' importedNamespace=QualifiedNameWithWildcard
;

///////////////
// functions //
///////////////

// a function definition
FunctionDefinition:
	{FunctionDefinition}
	'define' name=VariableName 'typeof' type=(FunctionType | VariableName) 
	'('
		(parameters+=FunctionParameterMember (',' parameters+=FunctionParameterMember)*)?
	')'
	'{'
		members+=FunctionBodyMember*
	'}'
	(
	'USES'
		uses+=FunctionUseMember (',' uses+=FunctionUseMember)*
	)?
;

// function types
FunctionType:
	'PROCESS' | 'CELL' | 'SYSTEM'  | 'REGION' 
;

// function parameter member
FunctionParameterMember:
	((type=VariableType) | (collection=CollectionID '<' type=(VariableType | VariableName) '>'))  name=VariableName (':' scope=FunctionParameterScope)?
;

// allowed scope of function parameters
FunctionParameterScope:
	'input' | 'output' | 'optional'
;

// function definition body member
FunctionBodyMember:
	RuleDefinition | DeviceDefinition | VariableDefinition | VariableAssignment | ATGCDefinition | PropertyDefinition
;

// function use member
FunctionUseMember:
	type=VariableType name=VariableName
;

///////////////
// variables //
///////////////

// a variable
VariableName:
	ID
;

// a variable complex
VariableComplex:
	{VariableComplex}
	components+=VariableName ('~' components+=VariableName)+ 
; 

// a variable attribute
VariableAttribute:
	{VariableAttribute}
	(name=VariableName | complex=VariableComplex) '.' attribute=VariableName
;


UserDefinedType:
	name=ID
;

// a definition of a variable
VariableDefinition:
	{VariableDefinition}
	definition=(VariableDefinitionBuiltIn | VariableDefinitionUserDefined | VariableDefinitionCollection | VariableDefinitionBasic)
	(':' qualifier=VariableQualifier)?
;

VariableDefinitionBuiltIn:
	{VariableDefinitionBuiltIn}
	type=VariableType (name=VariableName | complex=VariableComplex)
	(
	'=' 'new' constructor=(VariableType | VariableName) '(' (parameters+=ParameterAssignment (',' parameters+=ParameterAssignment)*)? ')'
	)?
;

VariableDefinitionUserDefined:
	{VariableDefinitionUserDefined}
	type=VariableName name=VariableName
	(
	'=' 'new' constructor=VariableName '(' (parameters+=ParameterAssignment (',' parameters+=ParameterAssignment)*)? ')'
	)?
;

VariableDefinitionCollection:
	{VariableDefinitionCollection}
	(collection=CollectionID '<' type=(VariableType | VariableName) '>' name=VariableName)
	(
	'=' value=List ')'
	)?
;

VariableDefinitionBasic:
	{VariableDefinitionBasic}
	type=VariableType name=VariableName '=' expression=VariableExpression
;

// a parameter assignment
ParameterAssignment:
	name=VariableName '=' value=VariableExpressionObject
;

// a variable qualifier
VariableQualifier:
	'observable'
;

// variable types
VariableType:
	'MOLECULE' | 'CELL' | 'RIBOSOME' | 'PROMOTER' | 'PROTEIN' | 'DNA' | 'RNA' | 'GENE' | 'INTEGER' | 'RATE' | 'PROCESS' | 'SYSTEM' | 'CHASSIS' | 'COMPLEX'
;

// variable collections
CollectionID:
	'LIST' | 'SET' | 'HASH'
;

// a variable assignment
VariableAssignment:
	{VariableAssignment}
	variable=VariableAssignmentObject '=' expression=VariableExpression
;

VariableAssignmentObject:
	{VariableAssignmentObject}
	VariableName | VariableAttribute
;

VariableExpression:
	{VariableExpression}
	members+=VariableExpressionObject (VariableExpressionOperator members+=VariableExpressionObject)*
;

VariableExpressionObject:
	AtomicVariableExpressionObject | CompoundVariableExpressionObject
;

AtomicVariableExpressionObject:
	{AtomicVariableExpressionObject}
	variable=VariableName | attribute=VariableAttribute | complex=VariableComplex | value=REAL | quantity=Quantity | string=STRING
;

CompoundVariableExpressionObject:
	{CompoundVariableExpressionObject}
	list=List
;

VariableExpressionOperator:
	'+' | '-' | '|'
;

///////////
// rules //
///////////

// rule definition
RuleDefinition:
	{RuleDefinition}
	'RULE' name=VariableName ':' (lhs+=RuleObject ('+' lhs+=RuleObject)*)? ('->'|reversible?='<->') (rhs+=RuleObject ('+' rhs+=RuleObject)*)?
;

// left or right hand side of rule
RuleObject:
	{RuleObject}
	VariableName | VariableComplex 
;

/////////////
// devices //
/////////////

// device definition
DeviceDefinition:
	{DeviceDefinition}
	'DEVICE' name=VariableName '=' 'new' 'DEVICE'
	'('
		'parts' '=' parts=List
	')'
	'('
		('input' '=' input=List)?
		(',' 'output' '=' outputput=List)?
//		(parameters+=ParameterAssignment (',' parameters+=ParameterAssignment)*)?
	')'
	'{'
		(members+=DeviceMembers*)
	'}'
;

DeviceMembers:
	VariableDefinition | PropertyDefinition | ATGCDefinition
;

////////////////
// atgc rules //
////////////////

ATGCDefinition:
	{ATGCDefinition}
	'ATGC' command=ATGCCommand ':' arguments+=VariableName (',' arguments+=VariableName)*
;

ATGCCommand:
	'ARRANGE'
;

/////////////////////////
// model checker rules //
/////////////////////////

PropertyDefinition:
	{PropertyDefinition}
	'VERIFY'
	((
		'[' property+=Property (BooleanOperator property+=Property)* ']' condition=PropertyCondition	
	) | 
	(
		'EXPECTED' '[' name=VariableName ']' 'AT TIME INSTANT' time=Quantity 'IS' ((operator=RelationalOperator concentration=Quantity) | '?')
	))
;

Property:
	{Property}
	lhs=VariableName operator=RelationalOperator rhs=Quantity
;

PropertyCondition:
	{PropertyCondition}
	(
	'WILL HOLD' |
	'NEVER HOLDS' |
	'ALWAYS HOLDS' |
	'EVENTUALLY HOLDS' | 
	'SOMETIMES HOLDS'
	)
	(
	'WITHIN TIME BOUND' '[' lowerBound=Quantity ',' upperBounds=Quantity ']'
		(
		'WITH PROBABILITY BOUND' ((operator=RelationalOperator probability=REAL) | '?') 
		)?
	)?
	(
	'GIVEN' initialConditions+=PropertyInitialCondition (',' initialConditions+=PropertyInitialCondition)*
	)?
;

PropertyInitialCondition:
	{PropertyInitialCondition}
	variable=VariableAssignmentObject '=' value=Quantity	
;

/////////////////
// basic types //
/////////////////

// a real number
REAL:
	Decimal | DecimalExp
;

Decimal hidden():
	('+'|'-')?  INT ('.' INT)?
;

DecimalExp hidden():
	('+'|'-')? INT ('.' INT)? ('E'|'e') ('+'|'-')? INT
;

// a quantity with units
Quantity:
	{Quantity}
	value=REAL units=Unit
;

Unit:
	's' | 'min' | 'mins' | 's^-1' | 'min^-1' | 'M' | 'mM' | 'uM' | 'nM' | 'pM' | 'fM' | 'molecule' | 'molecules' 
;
// relational operators
RelationalOperator:
	'==' | '!=' | '<' | '>' | '<=' | '>='
;

// boolean operator
BooleanOperator:
	'&' | '|' | 'AND' | 'OR' | 'AND' 'NOT' | 'OR' 'NOT'
;

// qualified name
QualifiedNameWithWildcard:
	QualifiedName ('.*')?
;

QualifiedName:
	ID ('.' ID)*
;

List:
	{List}
	'[' entries+=AtomicVariableExpressionObject (',' entries+=AtomicVariableExpressionObject)* ']'
;