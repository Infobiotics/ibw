// xtext grammar for Roadblock IBL language
// 2013, released under GNU GPL V3
// 12 Feb 2014

grammar roadblock.xtext.ibl.Ibl with org.eclipse.xtext.common.Terminals

generate ibl "http://www.xtext.roadblock/ibl/Ibl"

/////////////////////
// top level rules //
/////////////////////

// a model is composed of top level model members
Model:
	{Model}
	members+=ModelMember*
;
	
// model members are an import statement, variable definition or function definition
ModelMember:
	ImportStatement | FunctionDefinition
;

//////////////////////
// import statement //
//////////////////////

ImportStatement:
	{Import}
	'import' importedNamespace=QualifiedNameWithWildcard
;

/////////////////////////
// Function definition //
/////////////////////////

// function types
FunctionType:
	'PROCESS' | 'SYSTEM' | 'CHROMOSOME' | 'PLASMID' | 'CELL' |  'REGION'
;

// a function definition
FunctionDefinition:
	{FunctionDefinition}
	'define' name=VariableName 'typeof' functionBody = FunctionBodyType 
	(
	'USES'
		uses+=FunctionUseMember (',' uses+=FunctionUseMember)*
	)?
;


FunctionBodyType:
	ProcessBody | SystemBody | PlasmidBody | ChromosomeBody | CellBody | RegionBody | CustomFunctionBody
;

// Process body definition
ProcessBody:
	{ProcessBody}
	 'PROCESS'	 
	 functionContent = FunctionContent	
;

// System body definition
SystemBody:
	{SystemBody}
	 'SYSTEM'
	 functionContent = FunctionContent
;

// Plasmid body definition
PlasmidBody:
	{PlasmidBody}
	 'PLASMID'
	 functionContent = FunctionContent
;

// Chromosome body definition
ChromosomeBody:
	{ChromosomeBody}
	 'CHROMOSOME'
	 functionContent = FunctionContent
;

// Cell body definition
CellBody:
	{CellBody}
	 'CELL'
	 functionContent = FunctionContent
;

// Region body definition
RegionBody:
	{RegionBody}
	 'REGION'
	 functionContent = FunctionContent
;

// User defined function body definition
CustomFunctionBody:
	{CustomFunctionBody}
	 functionType=VariableName
	 functionContent = FunctionContent
;


FunctionContent:
	{FunctionContent}
	'('
		(parameters+=FunctionParameterMember (',' parameters+=FunctionParameterMember)*)?
	')'
	'{'
		members+=FunctionBodyMember*
	'}'
;
//////////////////
// Body members //
//////////////////


// See iblRefactoringGrammar.R for some automation
FunctionBodyMember:
	ATGCDefinition | CellInstantiation | ChromosomeInstantiation | DeviceDefinition | PlasmidInstantiation | ProcessInstantiation | PropertyDefinition | 
	RuleDefinition | SystemInstantiation | 
	VariableAssignment | VariableDefinition
;

//////////////////////
// function members //
//////////////////////

// function parameter member
FunctionParameterMember:
	((type=VariableKind2) | (collection=CollectionID '<' type = VariableKind2 '>'))  name=VariableName (':' scope=FunctionParameterScope)?
;

// allowed scope of function parameters
FunctionParameterScope:
	'input' | 'output' | 'optional'
;

// function use member
FunctionUseMember:
	type=VariableType name=VariableName
;

/////////////
// devices //
////////////

// device definition
DeviceDefinition:
	{DeviceDefinition}
	'DEVICE' name=VariableName '=' 'new' 'DEVICE'
	'('
		'parts' '=' parts=List
	')'
	'('
		('input' '=' input=List)?
		(',' 'output' '=' outputput=List)?
	')'
	'{'
		(members+=DeviceMembers*)
	'}'
;

DeviceMembers:
	VariableDefinition | PropertyDefinition | ATGCDefinition | ProcessInstantiation | RuleDefinition | VariableAssignment
;

////////////////////
// instantiations //
////////////////////

// System instantiation 
ProcessInstantiation:
	{ProcessInstantiation}
	'PROCESS' name=VariableName
	(
	'=' 'new' constructor=VariableName '(' (parameters+=ParameterAssignment (',' parameters+=ParameterAssignment)*)? ')'
	)?
;

// System instantiation 
SystemInstantiation:
	{SystemInstantiation}
	'SYSTEM' name=VariableName
	(
	'=' 'new' constructor=VariableName '(' (parameters+=ParameterAssignment (',' parameters+=ParameterAssignment)*)? ')'
	)?
;

// Plasmid instantiation 
PlasmidInstantiation:
	{PlasmidInstantiation}
	'PLASMID' name=VariableName
	(
	'=' 'new' constructor=VariableName '(' (parameters+=ParameterAssignment (',' parameters+=ParameterAssignment)*)? ')'
	)?
;

// Chromosome instantiation 
ChromosomeInstantiation:
	{ChromosomeInstantiation}
	'CHROMOSOME' name=VariableName
	(
	'=' 'new' constructor=VariableName '(' (parameters+=ParameterAssignment (',' parameters+=ParameterAssignment)*)? ')'
	)?
;

// Cell instantiation 
CellInstantiation:
	{CellInstantiation}
	'CELL' name=VariableName
	(
	'=' 'new' constructor=VariableName '(' (parameters+=ParameterAssignment (',' parameters+=ParameterAssignment)*)? ')'
	)?
;



///////////////
// variables //
///////////////


VariableKind:
	VariableName | VariableComplex
;

VariableName:
	{VariableName}
	name = 	ID
;

VariableComplex:
	{VariableComplex}
	components+=VariableName ('~' components += VariableName)+
;

VariableKind2:
	{VariableKind2}
	VariableType | VariableName
;


//// a variable
//VariableName:
//	ID
//;
//
//// a variable complex
//VariableComplex:
//	{VariableComplex}
//	components+=VariableName ('~' components+=VariableName)+ 
//; 


// variable types
VariableType:
	'MOLECULE' | 'COMPLEX' | 'RIBOSOME' | 'PROMOTER' | 'PROTEIN' | 'DNA' | 'RNA' | 'GENE' | 'INTEGER' | 'RATE' 
;


// a variable attribute
VariableAttribute:
	{VariableAttribute}
	name=VariableKind '.' attribute=VariableName
;

// a definition of a variable
VariableDefinition:
	{VariableDefinition}
	definition=(VariableDefinitionBuiltIn | VariableDefinitionUserDefined | VariableDefinitionCollection | VariableDefinitionBasic)
	(':' qualifier=VariableQualifier)?
;

// a variable qualifier
VariableQualifier:
	'observable'
;

VariableDefinitionBuiltIn:
	{VariableDefinitionBuiltIn}
	type=VariableType name=VariableName
	(
	'=' 'new' constructor=VariableKind2 '(' (parameters+=ParameterAssignment (',' parameters+=ParameterAssignment)*)? ')'
	)?
;

VariableDefinitionUserDefined:
	{VariableDefinitionUserDefined}
	type=VariableName name=VariableName
	(
	'=' 'new' constructor=VariableKind2'(' (parameters+=ParameterAssignment (',' parameters+=ParameterAssignment)*)? ')'
	)?
;


VariableDefinitionCollection:
	{VariableDefinitionCollection}
	(collection=CollectionID '<' type=VariableKind2 '>' name=VariableName)
	(
	'=' value=List ')'
	)?
;

// variable collections
CollectionID:
	'LIST' | 'SET' | 'HASH'
;

VariableDefinitionBasic:
	{VariableDefinitionBasic}
	type=VariableType name=VariableName '=' expression=VariableExpression
;

// a parameter assignment
ParameterAssignment:
	name=VariableName '=' value=VariableExpressionObject
;

// a variable assignment
VariableAssignment:
	{VariableAssignment}
	variable=VariableAssignmentObject '=' expression=VariableExpression
;

VariableAssignmentObject:
//	{VariableAssignmentObject}
	VariableName | VariableAttribute
;

VariableExpression:
	{VariableExpression}
	members+=VariableExpressionObject (VariableExpressionOperator members+=VariableExpressionObject)*
;

VariableExpressionObject:
	AtomicVariableExpressionObject | CompoundVariableExpressionObject
;

AtomicVariableExpressionObject:
	{VariableReference} variable = VariableName | 
	{VariableAttibute} attribute=VariableAttribute | 
	{VariableComplex} complex=VariableComplex | 
	{RealConstant} value=REAL | 
	{Quantity} quantity = Quantity | 
	{StringConstant} string=STRING
;

CompoundVariableExpressionObject:
	{CompoundVariableExpressionObject}
	list=List
;

VariableExpressionOperator:
	'+' | '-' | '|'
;

///////////
// rules //
///////////

// rule definition
RuleDefinition:
	{RuleDefinition}
	'RULE' name=VariableName ':' (lhs+= RuleObject ('+' lhs+=RuleObject)*)? ('->'|reversible?='<->') (rhs += RuleObject('+' rhs+=RuleObject)*)?
;

RuleObject:
	VariableKind | Outside
;

Outside:
	{Outside}
	'OUTSIDE'
;
////////////////
// atgc rules //
////////////////
ATGCDefinition:
	{ATGCDefinition}
	'ATGC' command = (ATGCCloningSites | ATGCArrange | ATGCDirection)
;

ATGCArrange:
	{ATGCArrange}
	'ARRANGE' arguments+=VariableName  (',' arguments+=VariableName)*
;

ATGCCloningSites:
	{ATGCCloningSites}
	'CLONING SITES' ':' cloningsites = INT
;

ATGCDirection: 
	{ATGCDirection}
	'DIRECTION' ':' direction = ('FORWARD' | 'BACKWARD')
;

/////////////////////////
// model checker rules //
/////////////////////////

PropertyDefinition:
	{PropertyDefinition}
	'VERIFY' property=(ProbabilityProperty | RewardProperty)	
;

ProbabilityProperty:
	{ProbabilityProperty}
	stateFormula1=StateFormula
	((		
	((isEventually?='EVENTUALLY HOLDS' | isNever?='NEVER HOLDS' | isAlways?='ALWAYS HOLDS') |
	((isUntilThen?='WILL HOLD UNTIL THEN' | isFollowedBy?='IS FOLLOWED BY') stateFormula2=StateFormula))		
	
	(timeInstant=TimeInstant | timeInterval=TimeInterval)?
	)  |
	
	(isSteadyState?='HOLDS IN STEADY-STATE' | isInfinitelyOften?='HOLDS INFINITELY OFTEN' 	
	))
	(probabilityConstraint=ProbabilityConstraint)?
	(
	'GIVEN' initialConditions+=PropertyInitialCondition (',' initialConditions+=PropertyInitialCondition)*
	)?
;

RewardProperty:
	{RewardProperty}
	'EXPECTED' '[' name=VariableKind ']' timeInstant=RewardTimeInstant 'IS ' concentrationConstraint=ConcentrationConstraint 
    (
	'GIVEN' initialConditions+=PropertyInitialCondition (',' initialConditions+=PropertyInitialCondition)*
	)?
;

StateExpression:
	{StateExpression}
	name = VariableKind  operator=RelationalOperator concentrationQuantity=ConcentrationQuantity
;

StateFormula:
	{StateFormula}
	formula=
	'[' atomicFormula=StateExpression']' | 
	'[' isNegation?='NOT' negatedFormula=StateFormula']' |
	'[' leftFormula=StateFormula (isConjunction?='AND' | isDisjunction?='OR' | isImplication?='IMPLIES') rightFormula=StateFormula ']'
;

TimeInstant:
	{TimeInstant}
	(isEqualTo?='AT' timeInstant=INT | isLessThanOrEqual?='BEFORE' timeInstant=INT | isGreaterThanOrEqual?='AFTER' timeInstant=INT) timeUnit=TimeUnit
;

TimeInterval:
	{TimeInterval}
	'WITHIN' '[' lowerBound=INT ',' upperBound=INT ']' timeUnit=TimeUnit
;

RewardTimeInstant:
	{RewardTimeInstant}
	(isEqualTo?='AT' | isLessThanOrEqual?='WITHIN') timeValue=INT timeUnit=TimeUnit
;

ProbabilityConstraint:
	{ProbabilityConstraint}
	'WITH PROBABILITY' ((operator=RelationalOperator probability=UnitInterval) | hasUnknownProbability?='?') 
;

ConcentrationConstraint:
	{ConcentrationConstraint}
	(operator=RelationalOperator value=REAL unit=ConcentrationUnit) | isUnknown?='?' 
;

//StateFormula:
//	{StateFormula}
//'[' stateFormula+=StateFormula (BooleanOperator stateFormula+=StateFormula)* ']'

PropertyInitialCondition:
	{PropertyInitialCondition}
	variable=VariableAssignmentObject '=' value=ConcentrationQuantity	
;

/////////////////
// basic types //
/////////////////

REAL:
	Decimal | DecimalExp
;

UnitInterval:
	'1.0' | '.' (INT)* | '0.' (INT)* 
;

Decimal hidden():
	('+'|'-')?  INT ('.' INT)?
;

DecimalExp hidden():
	('+'|'-')? INT ('.' INT)? ('E'|'e') ('+'|'-')? INT
;

TimeUnit:
	's' | 'min' | 'mins' 
;

FluxUnit:
's^-1' | 'min^-1'	
;

ConcentrationUnit:
	'M' | 'mM' | 'uM' | 'nM' | 'pM' | 'fM' | 'molecule' | 'molecules' 
;

Unit:
	TimeUnit | FluxUnit | ConcentrationUnit
;

// a quantity with units
Quantity:
	{Quantity}
	value=REAL units=Unit
;

ConcentrationQuantity:
	{ConcentrationQuantity}
	value=REAL unit=ConcentrationUnit
;

// relational operators
RelationalOperator:
	'==' | '!=' | '<' | '>' | '<=' | '>='
;

// boolean operator
BooleanOperator:
	'NOT' |'AND' | 'OR' | 'IMPLIES'
;

// qualified name
QualifiedNameWithWildcard:
	QualifiedName ('.*')?
;

QualifiedName:
	ID ('.' ID)*
;

List:
	{List}
	'[' (entries+=AtomicVariableExpressionObject (',' entries+=AtomicVariableExpressionObject)*)? ']'
;